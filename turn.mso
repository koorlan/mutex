/************************************/
/* Peterson's algorithm with TURN 	*/
/************************************/


/*
 	Description :
 		P1 and P2, 2 process
 		TURN, a shared value
*/

/*
	Initial system state
 	- Turn :: 1, 2
 	- P1 P2 start code excution
*/


/************************************************/
/* Subsystem  	: Process 		                */
/* States       : critical, mvturn or test 		*/
/* Transitions  : move and loop        			*/
/************************************************/

process=[start,critical,wait,end]
{
	etat=4;
	init=0;
	2=critical;
	1=wait;
	3=end;
	0= start;

	0->1[mvturn];			// change TURN value
	1->2[test]; 			// test and wait
	2->0  [reset]	;				// enter in critical code section
	0->3[stop];				// stop this code section
};;



/************************************************/
/* Subsystem  	: Shared 	                    */
/* States       : one::two						*/
/* Transitions  : change or not the TURN value  */
/************************************************/

shared=[one,two]
{
	etat=2;
	init= 0,1;						// 2 initial TURN values
	0=one;
	1=two;
	0->1[mvturn2];  				// 2nd process changes turn
	1->0[mvturn1];	     			// 1st process changes turn
	0->0[mvturn1, turn1];			// 1st process tests or changes turn for nothing
	1->1[mvturn2, turn2];			// 2nd process tests or changes turn for nothing
};;


systeme=<process P1, process P2, shared TURN>
{
	<mvturn,_,mvturn1> -> p1;
	<_,mvturn,mvturn2> -> p2;

	<test,_,turn2> -> p1;
	<_,test,turn1> -> p2;


	<stop,_,_> -> p1;
	<_,stop,_> -> p2;
};;

/*
	deadlock happens when a process is waiting for a TURN value move and the other has left this code section
*/

//Define CTL to verifiy
//TODO : Moi j'avais la formule en dessous ...  systeme += state_deadlock <- !EX(true) && (P1.wait || P2.wait)					;; //Progress
systeme += state_critical <- P1.critical && P2.critical 								;; //Mutual Exclusion
systeme += state_deadlock <- !EX(true) && !(P1.end && P2.end)						;; //Progress
systeme += state_equity <- AG(P1.wait -> EF(P1.critical))								;; //Bounded Waiting
systeme += state_strong_equity <- AG(P1.wait -> AF(P1.critical))				;; //Bounded Waiting

//Assign state to var
deadlock = systeme -> state_deadlock;;
critical = systeme -> state_critical ;;
equity = systeme -> state_equity;;
strong_equity = systeme -> state_strong_equity;;

//Print Result
todot primitiveTDot/process.dot process;;
todot primitiveTDot/shared.dot shared;;

todot primitiveTDot/system.dot systeme;;

todot primitiveTDot/deadlock.dot deadlock ;;
todot primitiveTDot/critical.dot critical ;;
todot primitiveTDot/equity.dot equity ;;
todot primitiveTDot/strong_equity.dot strong_equity ;;
